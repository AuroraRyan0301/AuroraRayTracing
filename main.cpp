#include <iostream>
#include <fstream>
#include <random>
#include <vector>

#include "mingw.thread.h"

#include "initial.h"
#include "thread_utils.h"
#include "constant.h"

int main() {

    hitable* world = world_initial();
    std::cout << "world initialized" << std::endl;
    camera cam = cam_initial();
    std::cout << "camera initialized" << std::endl;

    unsigned int numCores = std::thread::hardware_concurrency();
    int numThreads = numCores;

    // 创建线程容器
    std::vector<std::thread> threads;

    // imageHeight，imageWidth创建vec3画布
    vec3 **image = new vec3*[imageHeight];
    for (int i = 0; i < imageHeight; i++)
    {
        image[i] = new vec3[imageWidth];
    }

    for (int th = 0; th < numThreads; th++)
    {
        threads.emplace_back(taskAlloc, th, numThreads, world, cam, image);
        // 打印分配成功
        std::cout << "thread " << th << " allocated" << std::endl;
    }

    for (auto& thread : threads)
    {
        thread.join(); //等待当前所有线程执行完毕，再继续执行主线程
    }

    std::cout << "rendering completed!" << std::endl;

    // 输出图片
    std::ofstream file("output.ppm", std::ios::binary);
    file << "P3\n" << "# Generated by AuroraRyan's ray tracing kernel\n" << imageWidth << " " << imageHeight << "\n" << 255 << "\n";

    for (int j = imageHeight-1; j >= 0; j--)
    {
        for (int i = 0; i < imageWidth; i++)
        {
            int ir = int(image[j][i].r());
            int ig = int(image[j][i].g());
            int ib = int(image[j][i].b());

            file << ir << " " << ig << " " << ib << "\n";
        }
    }
    
    file.close();

    std::cout << "image output completed!" << std::endl;

    //清除图片缓存
    for (int i = 0; i < imageHeight; i++)
    {
        delete[] image[i];
    }
    delete[] image;


    return 0;
}